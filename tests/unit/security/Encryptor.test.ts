/* eslint-disable max-nested-callbacks */
import { afterEach, beforeEach, describe, expect, it, vi, type Mock } from 'vitest';

const loggerError = vi.fn();

vi.mock('@config/logger', () => ({
  Logger: {
    info: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn(),
    error: loggerError,
  },
}));

async function loadEncryptor(tag: string): Promise<typeof import('@/security/Encryptor')> {
  return import('@/security/Encryptor?v=' + tag);
}

function mockCryptoDeterministic(): void {
  vi.doMock('node:crypto', () => ({
    pbkdf2Sync: vi.fn(
      (
        password: string,
        salt: string,
        iterations: number,
        keyLength: number,
        digest: string
      ): Buffer => Buffer.from(`${password}|${salt}|${iterations}|${keyLength}|${digest}`)
    ),
    randomBytes: vi.fn((size: number): Buffer => Buffer.alloc(size, 0x61)),
  }));
}

describe('Encryptor', () => {
  beforeEach(() => {
    vi.resetModules();
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  it('should use PBKDF2 by default (when bcrypt is missing)', async () => {
    mockCryptoDeterministic();
    // Force bcrypt import to fail so PBKDF2 path is used.
    vi.doMock('bcrypt', () => {
      throw new Error('Cannot find module');
    });

    const { Encryptor } = await loadEncryptor('pbkdf2-default');

    const plainText = 'test-string'; // NOSONAR
    const hash = await Encryptor.hash(plainText);

    expect(hash).toContain('pbkdf2$');
    expect(Encryptor.getAlgorithm()).toBe('pbkdf2');

    const isValid = await Encryptor.verify(plainText, hash);
    expect(isValid).toBe(true);

    const isInvalid = await Encryptor.verify('wrong', hash);
    expect(isInvalid).toBe(false);

    expect(loggerError as unknown as Mock).toHaveBeenCalledWith(
      'bcrypt not installed, falling back to PBKDF2',
      expect.any(Error)
    );
  });

  it('should verify PBKDF2 hash correctly', async () => {
    mockCryptoDeterministic();
    vi.doMock('bcrypt', () => {
      throw new Error('Cannot find module');
    });

    const { Encryptor } = await loadEncryptor('pbkdf2-verify');

    const plainText = 'test-secret';
    // Manually create a PBKDF2 hash or use the one generated by hash()
    const hash = await Encryptor.hash(plainText);

    expect(await Encryptor.verify(plainText, hash)).toBe(true);
    expect(await Encryptor.verify('wrong', hash)).toBe(false);
  });

  it('returns false for malformed PBKDF2 hashes (missing parts)', async () => {
    mockCryptoDeterministic();
    vi.doMock('bcrypt', () => {
      throw new Error('Cannot find module');
    });

    const { Encryptor } = await loadEncryptor('pbkdf2-malformed');

    await expect(Encryptor.verify('pw', 'pbkdf2$')).resolves.toBe(false);
    await expect(Encryptor.verify('pw', 'pbkdf2$123')).resolves.toBe(false);
    await expect(Encryptor.verify('pw', 'pbkdf2$123$salt')).resolves.toBe(false);
  });

  it('returns false when PBKDF2 stored hash length differs', async () => {
    mockCryptoDeterministic();
    vi.doMock('bcrypt', () => {
      throw new Error('Cannot find module');
    });

    const { Encryptor } = await loadEncryptor('pbkdf2-len-mismatch');

    // computed will be a hex string from mockCryptoDeterministic(); make storedHash a different length.
    await expect(Encryptor.verify('pw', 'pbkdf2$1$salt$abc')).resolves.toBe(false);
  });

  it('returns false and logs when PBKDF2 verification throws', async () => {
    vi.doMock('node:crypto', () => ({
      pbkdf2Sync: vi.fn(() => {
        throw new Error('boom');
      }),
      randomBytes: vi.fn((size: number): Buffer => Buffer.alloc(size, 0x61)),
    }));
    vi.doMock('bcrypt', () => {
      throw new Error('Cannot find module');
    });

    const { Encryptor } = await loadEncryptor('pbkdf2-throws');

    await expect(Encryptor.verify('pw', 'pbkdf2$1$salt$hash')).resolves.toBe(false);
    expect(loggerError as unknown as Mock).toHaveBeenCalledWith(
      'PBKDF2 verification failed',
      expect.any(Error)
    );
  });

  it('reuses loaded bcrypt on subsequent calls (covers ensureLoaded early return)', async () => {
    const mockBcrypt = {
      hash: vi.fn().mockResolvedValue('$2b$10$mockhash'),
      compare: vi.fn().mockResolvedValue(true),
    };

    vi.doMock('bcrypt', () => ({ default: mockBcrypt }));
    mockCryptoDeterministic();

    const { Encryptor } = await loadEncryptor('bcrypt-reuse');

    await Encryptor.hash('pw1');
    await Encryptor.hash('pw2');

    expect(mockBcrypt.hash).toHaveBeenCalledTimes(2);
  });

  it('returns the same in-flight bcrypt load promise for concurrent calls', async () => {
    const mockBcrypt = {
      hash: vi.fn().mockResolvedValue('$2b$10$mockhash'),
      compare: vi.fn().mockResolvedValue(true),
    };

    vi.doMock('bcrypt', () => ({ default: mockBcrypt }));
    mockCryptoDeterministic();

    const { Encryptor } = await loadEncryptor('bcrypt-concurrent');

    await Promise.all([Encryptor.hash('pw1'), Encryptor.hash('pw2')]);

    expect(mockBcrypt.hash).toHaveBeenCalledTimes(2);
  });

  it('loads bcrypt when provided as named exports (no default export)', async () => {
    const mockBcrypt = {
      hash: vi.fn().mockResolvedValue('$2b$10$mockhash'),
      compare: vi.fn().mockResolvedValue(true),
    };

    vi.doMock('bcrypt', () => ({
      default: undefined,
      ...mockBcrypt,
    }));
    mockCryptoDeterministic();

    const { Encryptor } = await loadEncryptor('bcrypt-no-default');

    const hash = await Encryptor.hash('pw');
    expect(hash).toBe('$2b$10$mockhash');
    expect(Encryptor.getAlgorithm()).toBe('bcrypt');
  });

  it('should use bcrypt if available', async () => {
    const mockBcrypt = {
      hash: vi.fn().mockResolvedValue('$2b$10$mockhash'),
      compare: vi.fn().mockResolvedValue(true),
    };

    vi.doMock('bcrypt', () => ({ default: mockBcrypt }));
    mockCryptoDeterministic();

    // We need to reload the module to pick up the mock
    const { Encryptor: ReloadedEncryptor } = await loadEncryptor('bcrypt-hash');

    const plainText = 'test-string';
    const hash = await ReloadedEncryptor.hash(plainText);

    expect(hash).toBe('$2b$10$mockhash');
    expect(ReloadedEncryptor.getAlgorithm()).toBe('bcrypt');
    expect(mockBcrypt.hash).toHaveBeenCalled();
  });

  it('should verify bcrypt hash', async () => {
    const mockBcrypt = {
      hash: vi.fn(),
      compare: vi.fn().mockResolvedValue(true),
    };

    vi.doMock('bcrypt', () => ({ default: mockBcrypt }));
    mockCryptoDeterministic();

    const { Encryptor: ReloadedEncryptor } = await loadEncryptor('bcrypt-verify');

    const plainText = 'test-string';
    const hash = '$2b$10$existinghash';

    const isValid = await ReloadedEncryptor.verify(plainText, hash);
    expect(isValid).toBe(true);
    expect(mockBcrypt.compare).toHaveBeenCalledWith(plainText, hash);
  });

  it('should throw error if verifying bcrypt hash without bcrypt', async () => {
    mockCryptoDeterministic();
    vi.doMock('bcrypt', () => {
      throw new Error('Cannot find module');
    });

    const { Encryptor: ReloadedEncryptor } = await loadEncryptor('bcrypt-missing-verify');

    const hash = '$2b$10$existinghash';
    await expect(ReloadedEncryptor.verify('password', hash)).rejects.toThrow(
      'bcrypt not available to verify hash'
    );
  });
});
